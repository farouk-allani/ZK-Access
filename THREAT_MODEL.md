# ZK-Access Threat Model & Security Analysis

This document provides a rigorous security analysis for Aleo protocol engineers and security auditors.

---

## 1. WHAT AN ADVERSARY CAN SEE ON-CHAIN

### 1.1 Public Mappings

| Mapping | Visibility | What Adversary Sees | What Adversary CANNOT Infer |
|---------|------------|---------------------|------------------------------|
| `identity_nullifiers` | Public | Set of field values | Which identity each nullifier belongs to |
| `used_binding_nonces` | Public | Set of field values | Which identity created which binding |
| `authorized_issuers` | Public | Issuer addresses | Which credentials they issued |
| `revoked_nullifiers` | Public | Set of field values | Which credential was revoked |
| `issuer_nonces` | Public | Set of field values | Which credential each nonce corresponds to |
| `consumed_nonces` | Public | Set of field values | Which proof was consumed |

### 1.2 Transaction Metadata

| Data | Visibility | Privacy Impact |
|------|------------|----------------|
| Transaction hash | Public | Unique identifier, no semantic content |
| Program ID | Public | Reveals which program was called |
| Function name | Public | Reveals operation type (create_identity, prove_kyc, etc.) |
| Encrypted inputs | Public | Ciphertext only, computationally indistinguishable from random |
| Encrypted outputs | Public | Ciphertext only |
| ZK Proof | Public | Verifiable, but reveals nothing about witness |
| Fee | Public | Could correlate transactions by fee patterns |
| Timestamp | Public | Temporal correlation possible |

### 1.3 What Remains Private

| Data | Storage | Why It's Private |
|------|---------|------------------|
| Identity commitment | Record (encrypted) | AES encryption with owner's viewing key |
| Identity data hash | Record (encrypted) | Never stored in plaintext anywhere |
| User's actual age | Record (encrypted) | Only commitment proven, never revealed |
| User's country code | Record (encrypted) | ZK proof proves NOT in set, never reveals value |
| KYC status | Record (encrypted) | Only boolean assertion proven |
| Credential contents | Record (encrypted) | All fields encrypted |
| Identity-credential binding | Record (encrypted) | subject_commitment encrypted |
| Revocation secret | Never on-chain | Only issuer knows |

---

## 2. WHY ISSUERS CANNOT DEANONYMIZE USERS

### 2.1 Information Flow Analysis

```
ISSUANCE:
┌─────────────────────────────────────────────────────────────────────┐
│ Issuer knows at issuance time:                                       │
│ - Recipient address (necessary to create record)                    │
│ - Subject commitment (from identity binding)                        │
│ - Credential data (age, country, etc.)                             │
│ - Revocation secret (generated by issuer)                          │
│                                                                      │
│ Issuer can store: (recipient, subject_commitment, credential_data)  │
└─────────────────────────────────────────────────────────────────────┘

PROOF GENERATION:
┌─────────────────────────────────────────────────────────────────────┐
│ When user generates proof:                                           │
│ - Transaction reveals: function called (prove_age_minimum, etc.)    │
│ - Transaction reveals: encrypted proof record                       │
│ - Transaction reveals: revocation_nullifier (in finalize)          │
│                                                                      │
│ Issuer sees: A nullifier was checked (but cannot link to credential)│
│ Issuer CANNOT see: Who generated the proof                         │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 Why Issuer Cannot Link Proofs to Users

1. **Proof Generation is Anonymous**: The transaction sender is not revealed in the proof output
2. **Revocation Nullifier is One-Way**: `nullifier = H(credential_id + revocation_secret)` - issuer knows both, but the on-chain check only reveals the nullifier, not that the issuer's credential was used
3. **No Public Correlation**: The proof nonce is fresh each time, computed as `H(credential_id + verifier_context + block_height + user_seed)`

### 2.3 What Issuer CAN Do (Limitations)

- **At issuance**: Link recipient address to credential data (unavoidable)
- **If colluding with verifier**: Potentially correlate verifier context to narrow down users
- **Statistical analysis**: If only one credential exists with certain attributes, could infer

**Mitigation**: Users can:
- Use different addresses for receiving credentials
- Obtain credentials from multiple issuers
- Mix credential usage across time

---

## 3. WHY VERIFIERS CANNOT INFER HIDDEN ATTRIBUTES

### 3.1 ZK Circuit Analysis

For `prove_age_minimum(credential, minimum_age=18)`:

```
CIRCUIT CONSTRAINTS:
┌─────────────────────────────────────────────────────────────────────┐
│ Private witness:                                                     │
│ - credential.age (e.g., 34)                                        │
│ - credential.owner                                                  │
│ - credential.* (all credential fields)                             │
│                                                                      │
│ Public input:                                                        │
│ - minimum_age (18)                                                  │
│ - current_block                                                     │
│ - verifier_context                                                  │
│                                                                      │
│ Circuit proves:                                                      │
│ - ∃ credential such that:                                          │
│   - credential.owner == caller                                     │
│   - credential.age >= minimum_age                                  │
│   - credential.expires_at > current_block (or == 0)               │
│   - credential is not revoked                                      │
│                                                                      │
│ Output: claim_result = 1 (true) or transaction fails               │
└─────────────────────────────────────────────────────────────────────┘
```

**Why age is not revealed**:
- The constraint `credential.age >= minimum_age` is satisfied for any age ≥ 18
- The proof doesn't distinguish between age=18, age=34, or age=99
- Information theoretically: the proof leaks only that age ∈ [18, 255]

### 3.2 Country Non-Membership Proof

For `prove_country_not_restricted(credential, [408, 364, 760, 192])`:

```
CIRCUIT CONSTRAINTS:
┌─────────────────────────────────────────────────────────────────────┐
│ Circuit proves:                                                      │
│ - credential.country_code ≠ 408                                    │
│ - credential.country_code ≠ 364                                    │
│ - credential.country_code ≠ 760                                    │
│ - credential.country_code ≠ 192                                    │
│                                                                      │
│ Information leaked: country_code ∈ {0..65535} \ {408, 364, 760, 192}│
│ This is a set of 65,532 possible countries                         │
└─────────────────────────────────────────────────────────────────────┘
```

**Why country is not revealed**:
- The proof satisfies for ANY country not in the restricted set
- Verifier learns only that the user is from one of 190+ allowed countries
- No way to narrow down further from the proof alone

---

## 4. HOW REVOCATION DOES NOT LEAK IDENTITY

### 4.1 Nullifier Scheme Analysis

```
REVOCATION FLOW:
┌─────────────────────────────────────────────────────────────────────┐
│ At issuance:                                                         │
│   credential_id = H(issuer, recipient, subject_commitment, claims,  │
│                     issued_at, salt)                                │
│   revocation_secret = random field (issuer stores securely)        │
│   revocation_nullifier = H(credential_id + revocation_secret)      │
│                                                                      │
│ Nullifier is stored in user's credential record (encrypted)        │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ At revocation:                                                       │
│   Issuer calls: revoke_credential(credential_id, revocation_secret)│
│   Finalize computes: nullifier = H(credential_id + revocation_secret)│
│   Finalize sets: revoked_nullifiers[nullifier] = true              │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ At proof time:                                                       │
│   Finalize checks: revoked_nullifiers[credential.revocation_nullifier]│
│   If true → proof fails                                             │
│   If false → proof succeeds                                         │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 Why Revocation is Unlinkable

1. **Nullifier is One-Way**: Given `nullifier`, cannot compute `credential_id` without `revocation_secret`
2. **Revocation Secret is Private**: Only issuer knows it, never on-chain
3. **No User Identifier**: Revocation transaction doesn't include user address
4. **Many-to-One**: Same nullifier format for all credentials, no distinguishing pattern

### 4.3 Attack Scenarios and Mitigations

| Attack | Feasibility | Mitigation |
|--------|-------------|------------|
| Issuer leaks revocation secrets | Possible (operational) | HSM storage, access controls |
| Timing correlation (revocation → failed proof) | Possible if narrow time window | Batch revocations, delayed proofs |
| Brute force nullifier | Infeasible (256-bit hash) | Cryptographic security |
| Issuer correlates their own revocations | Possible (they know the secret) | Unavoidable, but doesn't affect other issuers |

---

## 5. AUTHORIZATION & OWNERSHIP GUARANTEES

### 5.1 Identity Ownership

| Check | Mechanism | Security Guarantee |
|-------|-----------|-------------------|
| Record consumption | Aleo runtime | Only owner's private key can spend record |
| `assert_eq(identity.owner, self.caller)` | ZK circuit | Belt-and-suspenders with runtime |
| Nullifier registration | Mapping | Prevents identity cloning |

**Why this is secure**:
- Aleo records use UTXO model: records are "spent" to be used
- Spending requires proving ownership via private key
- Even if attacker obtains record ciphertext, they cannot decrypt or spend without private key

### 5.2 Credential Issuance Authorization

| Check | Mechanism | Security Guarantee |
|-------|-----------|-------------------|
| `authorized_issuers[caller]` | Finalize mapping check | Only registered issuers can issue |
| `admin` mapping | One-time initialization | Admin cannot be changed |
| Issuance nonce | Finalize mapping check | Prevents replay attacks |

**Attack resistance**:
- Unauthorized issuer: Transaction fails in finalize
- Issuer impersonation: Requires issuer's private key
- Issuance replay: Nonce check fails

### 5.3 Revocation Authorization

| Check | Mechanism | Security Guarantee |
|-------|-----------|-------------------|
| `authorized_issuers[caller]` | Finalize check | Only authorized entities can revoke |
| Knowledge of `revocation_secret` | Required to compute nullifier | Only original issuer can revoke |

**Why non-issuer cannot revoke**:
- Must be authorized issuer (finalize check)
- Must know correct `revocation_secret` (never on-chain)
- Guessing secret: 254-bit entropy, computationally infeasible

### 5.4 Proof Ownership

| Check | Mechanism | Security Guarantee |
|-------|-----------|-------------------|
| Record consumption | Aleo runtime | Only credential owner can create proof |
| `assert_eq(credential.owner, self.caller)` | ZK circuit | Explicit ownership check |
| Verifier context | Proof binding | Prevents cross-verifier replay |
| Proof nonce | Consumed in finalize | Prevents proof replay |

---

## 6. KNOWN LIMITATIONS AND TRADEOFFS

### 6.1 Metadata Leakage

**Issue**: Transaction timing, fees, and function names are public

**Impact**:
- Statistical analysis could correlate user activity patterns
- High-frequency users more identifiable

**Mitigation**:
- Use Aleo's future private fee mechanism
- Randomize transaction timing
- Use relayers for transaction submission

### 6.2 Issuer Knowledge at Issuance

**Issue**: Issuer knows recipient address + credential data at issuance time

**Impact**:
- Issuer can maintain database linking addresses to real-world identity
- If issuer is compromised, this data could leak

**Mitigation**:
- Use different addresses for different credentials
- Obtain redundant credentials from multiple issuers
- Regulatory/contractual requirements on issuer data retention

### 6.3 Single-Point Revocation

**Issue**: Only the original issuer can revoke a credential

**Impact**:
- If issuer loses `revocation_secret`, credential cannot be revoked
- If issuer goes offline, no revocation possible

**Mitigation**:
- Credential expiry as fallback (built-in)
- Issuer should use secure backup for secrets
- Future: multi-sig revocation schemes

### 6.4 Verifier Trust

**Issue**: Verifier knows when a specific proof was presented

**Impact**:
- Colluding verifier + issuer could narrow down user identity
- Verifier could track proof presentation patterns

**Mitigation**:
- `verifier_context` binding prevents cross-verifier analysis
- Use intermediary verification services
- Legal/contractual restrictions on verifiers

### 6.5 Proof Non-Transferability

**Issue**: Proofs are bound to the credential owner's address

**Impact**:
- Cannot delegate proof presentation to third party

**Design Choice**: This is intentional - prevents proof selling/sharing

### 6.6 Circuit Expressiveness

**Issue**: Current implementation supports fixed claim types

**Impact**:
- Cannot prove arbitrary predicates without code changes

**Future Work**:
- Programmable claim circuits
- More flexible predicate system

---

## 7. CRYPTOGRAPHIC ASSUMPTIONS

The security of ZK-Access relies on:

| Assumption | Used For | Standard Security Level |
|------------|----------|------------------------|
| BHP256 collision resistance | Commitments, nullifiers | 128-bit |
| BHP256 preimage resistance | Hiding commitments | 128-bit |
| Aleo record encryption (AES-based) | Record privacy | 128-bit |
| Marlin zkSNARK soundness | Proof validity | Computational soundness |
| Discrete log hardness | Address/key derivation | 128-bit |

If any of these assumptions are broken, specific guarantees may fail:
- BHP256 broken → commitment collisions possible
- Encryption broken → record contents revealed
- zkSNARK broken → fake proofs possible

---

## 8. AUDIT CHECKLIST

### 8.1 Authorization

- [x] Identity creation requires unique nullifier
- [x] Identity updates require ownership (record consumption + assertion)
- [x] Credential issuance requires authorized issuer (finalize check)
- [x] Revocation requires authorized issuer + secret knowledge
- [x] Proof generation requires credential ownership

### 8.2 Privacy

- [x] No identity data in public mappings
- [x] No credential data in public mappings
- [x] Nullifiers are one-way (cannot reverse to identity/credential)
- [x] Proofs reveal only boolean results
- [x] Verifier cannot infer hidden attributes

### 8.3 Replay Prevention

- [x] Identity nullifiers prevent double-creation
- [x] Binding nonces prevent binding replay
- [x] Issuance nonces prevent credential replay
- [x] Proof nonces prevent proof replay
- [x] Verification IDs prevent result replay

### 8.4 Expiry & Validity

- [x] Credentials have expiry field
- [x] Proofs check expiry before generation
- [x] Verification checks proof freshness (MAX_PROOF_AGE)
- [x] Revocation prevents further proof generation

### 8.5 Edge Cases

- [x] expires_at == 0 handled as "never expires"
- [x] Empty restricted country list handled (use 0u16 as placeholder)
- [x] Multiple credentials per user supported
- [x] Multiple proofs from same credential supported (different nonces)
